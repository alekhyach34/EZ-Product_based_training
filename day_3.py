# -*- coding: utf-8 -*-
"""Day-3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n6TJz6ycIitP_ZVhSMdewo6zQefo0xw-
"""

#bitwise operators--15 lines
10&4+3

7+2&4+3&9

10|3&4

#invalid syntax
10&4~2

#invalid syntax
2~4^3*2

6|3&15

~9

~9+4&6

2^2

2^4

7<<1

7>>1

7<<2

7>>2

#xor of number itself is zero--->also even number of same numbers output is zero
5^5

#xor of number with 0 is number it self---->also odd number of same numbers output is zero
5^5^5

#XOR for multiple inputs
#even 1's-0
#odd 1's-1
4^6^5

#right shift--5/2=2
5>>1

#right shift--5/2=2 then 2/2=1
5>>2

#right shift--14/2=7 then 7/2=3 then 3/2=1 then 1/2=0
14>>4

#left shift
5<<2

#left shift -->9*power(2,4)-->9*54
9<<4

#left shift -->10*power(2,3)-->10*8
10<<3

#left shift -->5*power(2,2)-->5*4
5<<2

#after creating an array find the smallest missing positive integer
#i/p->my_array=[3,7,-5,-6,0,4] #my_array=[3,1,-5,-6,0,2]-->o/p=4
#o/p->1
'''def miss(arr):
    nums=set(arr)
    l=0
    while l in nums:
        l += 1
    return l
arr=list(map(int,input().split()))
res=miss(arr)
print(res)'''
my_array=list(map(int,input().split()))
min=0
x=set(my_array)
while min in x:
  min+=1
print(min)

#given an array l=[1,5,1,2,3,2,3] o/p:5
def findsingle(a,n):
  r=a[0]
  for i in range(1,n):
    r=r^a[i]
  return r
a=list(map(int,input().split()))
print(findsingle(a,len(a)))

#swapping 2 numbers using XOR
a,b=map(int,input().split())
print(a,b)
a=a^b
b=a^b
a=a^b
print(a,b)

#for the given number check kth bit is set or not
n=10
pos=int(input())
if(n&(1<<pos-1)==0):
  print("not set")
else:
  print("set")

#for the given number n find out xor of all n numbers
n=int(input())
xor=0
for i in range(1,n+1):
  xor=xor^i
print(xor)
#time complexity-O(n)

#for the given number n find out xor of all n numbers
n=int(input())
if n%4==0:
  print(n)
elif n%4==1:
  print(1)
elif n%4==2:
  print(n+1)
elif n%4==3:
  print(0)
#time complexity-O(1)
'''
n=1 1
2 3
3 0
4 4
5 1
6 7
7 0
8 8
9 1
10 11'''

#find out xor for all the given numbers,for the given range
'''l=2,r=5
2^3^4^5
l=4 to r=9
xor(1 to 9)^xor(1 to 3)
(1^2^3^4^5^6^7^8^9)^(1^2^3)
1 2 3 will get cancelled generalise xor(r)^xor(l-1)'''
#l=4
#r=9
def xor_range(l, r):
    def xor_up_to_n(N):
        if N % 4 == 0:
            return N
        elif N % 4 == 1:
            return 1
        elif N % 4 == 2:
            return N + 1
        else:
            return 0
    xor_result = xor_up_to_n(r) ^ xor_up_to_n(l - 1)

    return xor_result

# Test cases
#result1 = xor_range(2, 5)
result2 = xor_range(int(input()), int(input()))
print(result2)

#find number is odd or even
n=int(input())
if(n&1==0):
  print("even")
else:
  print("odd")

#find the fibonacci series(using iteration and recursion)
#find nth term in fibonacci series
n1=0
n2=1
if(n<0):
  print("not possible")
else:
  for i in range(0,n-1):
    n3=n1+n2
    n1=n2
    n2=n3
  print(n2)

